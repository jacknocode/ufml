# UFMLの設計思想と背景

## UFMLとは

UFML (User interface Flow Markup Language) は、アプリケーションの画面遷移やUI要求、さらには関連する非機能要求を、一貫性のあるテキストベースで記述するために設計された軽量マークアップ言語です。

AI/LLMとの連携を前提に、UI開発プロセスを変革することを目指して設計されました。UI開発プロセスの中では中間言語としての役割を果たします。

## なぜUFMLが必要か

PRDからUI設計に移行する際、以下のような課題が発生しています：

### 従来の課題

1. **PDMごとの記述の差異**
   - 画面遷移の定義が曖昧
   - 非機能要件の記述にばらつき
   - 要件の詳細度の違い

2. **手戻りの発生**
   - 画面数の見積もり誤り
   - 遷移パターンの認識違い
   - 非機能要件の後付け

3. **ステークホルダー間の認識齟齬**
   - デザイナー、エンジニア、PdM、QA間での仕様理解の違い
   - AI/LLMとの連携における解釈の不一致

## UFMLの目的

### 1. UI要件と非機能要件の統合管理

個々の画面（node）が持つべきUI要素、表示テキスト、インタラクションだけでなく、セキュリティ要件、パフォーマンス目標といった非機能要件も、UFMLの構造内で関連付けて記述できます。これにより、機能と非機能が一体となった要求管理を実現します。

### 2. チーム内コラボレーションの強化と認識統一

デザイナー、エンジニア、PdM、QAなど、多様なステークホルダーがUFMLという共通言語を用いることで、仕様に関する認識の齟齬を最小限に抑え、円滑なコミュニケーションを促進します。

### 3. AI/LLMによる開発体験(DX)とユーザー体験(UX)の最大化

UFMLの核心的な価値は、そのテキストベースの構造がAI、特にLLMと極めて高い親和性を持つ点にあります。LLMが理解しやすい形式でUI仕様を記述することで、以下のようなAIを活用した開発体験 (AI-Driven Developer Experience) の革新と、その先にある高品質なユーザー体験 (User Experience) の実現を強力に支援します。

## UFML記述構造

### ブロック定義

UFMLドキュメントは、主に2種類のブロックで構成されます：

#### 画面ブロック `[画面名]`
- アプリケーションの特定の画面やUIの状態を定義
- 角括弧 `[]` で一意の画面名を囲んで表現
- 内部には「UI要素」と「アクション」が含まれる
- 例: `[ログイン画面]`, `[商品詳細ページ]`

#### ユースケースブロック `(ユースケース名)`
- 画面とは直接紐付かない、特定のビジネスロジック、バックエンド処理、再利用可能なプロセスなどを定義
- 丸括弧 `()` で一意のユースケース名を囲んで表現
- 画面ブロックのアクションから呼び出すことが可能
- 例: `(ユーザー認証)`, `(在庫引き当て処理)`

### UI要素（画面ブロック内）

画面ブロック内には、その画面を構成するUI要素を記述します。各要素は行頭の記号で種類を示します：

- **T (Text)**: 画面に表示される静的なテキスト、ラベル、見出しなど
  - 例: `T ようこそ、ゲストさん`, `T 商品名`
- **E (Editable)**: ユーザーが入力や編集を行うフィールド（テキスト入力、チェックボックス、ラジオボタン、ドロップダウンなど）
  - 例: `E メールアドレス`, `E 利用規約に同意する`
- **B (Button)**: ユーザーがクリックなどの操作を行うボタン要素。アクションの起点となることが多い
  - 例: `B ログイン`, `B 検索実行`
- **O (Other)**: 上記（T, E, B）以外の、より複雑なUIコンポーネントや要素（テーブル、リスト、画像、カスタムコンポーネントなど）
  - 例: `O 商品一覧テーブル`, `O ユーザーアバター画像`

### インタラクションと遷移

画面ブロック内で、ユーザーの操作やイベントによって引き起こされる主要な動作を「インタラクション」として定義します：

- **区切り**: UI要素の記述パートの後、`--` (ハイフン2つ) の行で区切ってインタラクションパートを開始
- **基本構文**: `A [インタラクション説明] => 遷移先`
- **条件付き構文**: `A [インタラクション説明] ={条件}=> 遷移先`

#### 構文の詳細
- `A`: インタラクション定義の開始を示す
- `[インタラクション説明]`: そのインタラクションが何を行うかの簡潔な説明
- `=>`: 遷移または呼び出しを示す
- `={条件}=>`: 特定の条件が満たされた場合のみ遷移・呼び出しが発生することを示す

### PSAUコメント（非機能要件）

パフォーマンス(P)、セキュリティ(S)、可用性(A)、ユーザビリティ(U) に関する非機能要件や注釈を記述するためのコメントです。

- **記法**: 行頭に `//` をつけ、続けて `P:`, `S:`, `A:`, `U:` のいずれかと要件内容を記述
- **記述場所**: ブロックレベル（画面ブロック `[...]` やユースケースブロック `(...)` の定義直後）でのみ記述可能

#### 例
```
[管理者ダッシュボード]
//P: load_time <= 2s
//S: role=admin
//U: accessibility=AAA

T ユーザーリスト
O 操作ログテーブル
B 設定変更
--
A 設定変更 => 設定画面
```

## UFMLのメリット

### 1. 開発チームとAI間の認識統一
UI構造、インタラクションロジック、非機能要求(PSAU)を単一のテキストファイルに集約します。これにより、UFMLはデザイナー、エンジニア、PM、QA、そしてAI(LLM)にとっても共通言語となり、信頼できる唯一の情報源 (Single Source of Truth - SSOT)として機能します。

### 2. 非機能要求(PSAU)の設計早期組み込みと管理
パフォーマンス(P)、セキュリティ(S)、可用性(A)、ユーザビリティ(U)といった非機能要求を、画面ブロックやユースケースブロックレベルで、機能仕様と同時に定義・管理できます。

### 3. AI/LLM連携による開発体験(DX)と品質(UX)の向上
LLMが理解しやすい構造化テキスト形式は、AIによる高精度な分析・生成支援を可能にします。仕様レビューの自動化、テストケース・テストデータの自動生成、ドキュメント骨子作成、UIフレームワークに応じたコード雛形生成などを実現します。

### 4. 仕様変更への追従性と保守性の向上
仕様定義(UFML)と実装(コード)を分離することで、関心事を分離します。UFMLの修正を起点として、LLMによるコードの再生成や影響範囲の分析を活用することで、仕様変更への対応コストを削減し、仕様と実装間の乖離リスクを低減します。

## 想定ユースケース

### 基本的な活用シーン
- 画面設計（UI構成・遷移フロー）の厳密な要件定義と文書化
- 条件付き遷移（バリデーション／セキュリティ条件／表示制御）の明示
- PSAU（パフォーマンス、セキュリティ、可用性、ユーザビリティ）等の非機能要件の記録と管理

### AI/LLM活用ユースケース
- 要求仕様書やPRDからUFMLを自動生成
- UFMLから適合したUIコンポーネントの自動選定
- UFMLからUIコードを自動生成

### プロジェクトフェーズ別活用

#### PRDレビュー時
```
[ログイン画面]
//P: レスポンス0.5秒以内
//S: 多要素認証必須
//A: 24/365稼働
//U: エラー表示は日本語

E ユーザーID
E パスワード
B ログイン
--
A ログイン認証 ={認証成功}=> メインメニュー
A ログイン認証 ={認証失敗}=> ログイン画面
```

#### デザインレビュー時
- 非機能要件の確認
- 画面要素の過不足チェック
- 遷移パターンの検証

## UFMLの課題と考慮事項

### 1. 大規模プロジェクトでのスケーラビリティ
画面数や機能が非常に多い場合、単一または少数のUFMLファイルが長大化し、可読性や管理性が低下する懸念があります。

**対策**: プロジェクト開始前に、ファイル分割の基準、モジュール化の方法、共通定義の参照・インクルード方法といった運用ルールや規約を整備することが推奨されます。

### 2. 導入・学習コストとツールエコシステム
チームメンバー全員がUFMLの記法、ベストプラクティス、そしてその背景にある設計思想に習熟するには一定の時間が必要です。

### 3. 記述の明確性と一貫性の維持
インタラクション説明の命名規則、条件式の記述スタイル、ブロックや要素名の付け方などに一貫性がない場合、人間にとってもLLMにとっても解釈が困難になり、可読性や保守性が低下します。

### 4. 自動化への過信と人間によるレビューの重要性
LLMによるコード生成や分析は開発を加速させる強力な手段ですが、万能ではありません。生成されたコード、テストケース、ドキュメント、分析結果等は、必ず人間の専門家がレビューし、その妥当性を判断・修正するプロセスが不可欠です。

## 期待される効果

### 1. コミュニケーションの改善
- PDMとデザイナー間の認識統一
- 開発チームとの要件共有
- AI/LLMとの効果的な連携
- レビューの効率化

### 2. 品質の向上
- 非機能要件の見落とし防止
- 一貫性のある実装
- テスト要件の明確化
- AI支援による品質向上

### 3. 工数の削減
- 手戻りの減少
- レビュー時間の短縮
- ドキュメント作成の効率化
- AI活用による開発速度向上

## UFMLの未来図

### AI駆動開発の実現

UFMLは、AI/LLMとの連携により以下のような開発体験の変革を目指しています：

#### 1. 要求からのUFMLの自動生成
- **自然言語要求の構造化**: PRDや要求仕様書から自動的にUFML形式への変換
- **要件の網羅性チェック**: AIによる要件の抜け漏れ検出と補完提案
- **非機能要件の自動推論**: 機能要件からPSAU要件の自動生成と提案

#### 2. UFMLから適用可能なデザインシステムの自動選定
- **コンポーネントマッピング**: UI要素タイプ（T/E/B/O）から最適なデザインシステムコンポーネントの自動選定
- **デザインパターン推奨**: 画面構成とインタラクションパターンに基づく最適なUIパターンの提案
- **アクセシビリティ対応**: PSAU要件に基づく自動的なアクセシビリティ対応コンポーネントの選定

#### 3. 既存コードのUFML化による軽量保管
- **リバースエンジニアリング**: 既存のReact、Vue、Angular等のフロントエンドコードからUFMLへの自動変換
- **仕様の抽出と保管**: 複雑なコードベースから画面構成、遷移ロジック、UI要素を抽出してUFML形式で軽量保管
- **レガシーシステムの文書化**: 古いシステムの画面仕様をUFMLとして再構築し、保守性を向上

#### 4. UFMLエディターによる多ロールコラボレーション
- **リアルタイム共同編集**: 複数のステークホルダーが同時にUFMLを編集・レビュー可能
- **ロール別ビュー**:
  - **PdM視点**: 要件の網羅性、ビジネスロジックの整合性確認
  - **デザイナー視点**: UI要素の配置、遷移フローの可視化、デザインシステムとの整合性
  - **エンジニア視点**: 実装可能性、技術的制約、非機能要件の妥当性
  - **QA視点**: テストケース抽出、エッジケース特定、品質要件の確認
- **コメント・レビュー機能**: UFML要素単位でのコメント、承認フロー、変更履歴管理
- **自動通知システム**: 変更時の関係者への通知、レビュー依頼の自動化

#### 5. 統合開発環境の構築
- **リアルタイム検証**: UFML記述時のリアルタイムな構文チェックと整合性検証
- **プロトタイプ自動生成**: UFMLから動作するプロトタイプの即座な生成
- **テスト自動化**: インタラクション定義からE2Eテストシナリオの自動生成

### 開発プロセスの変革

```
従来: 要求 → 設計 → 実装 → テスト
      ↓     ↓     ↓     ↓
     PdM → Designer → Engineer → QA
     (順次引き継ぎ、認識齟齬のリスク)

未来: 要求 → UFML → AI支援による並行開発
      ↓
      UFMLエディター上での同時コラボレーション
      ↓
      PdM + Designer + Engineer + QA
      (リアルタイム共同作業、認識統一)
      ↓
      設計・実装・テストの同時進行
```

#### コラボレーションの具体例

**要件定義フェーズ**:
- PdMがUFMLで要件を記述
- デザイナーがUI要素の妥当性をリアルタイムでレビュー
- エンジニアが技術的制約をコメント
- QAがテスト観点での懸念を指摘

**設計フェーズ**:
- デザイナーがUFML要素をデザインシステムにマッピング
- エンジニアが実装方針をUFMLコメントで共有
- PdMがビジネス要件との整合性を確認
- 全員がリアルタイムで変更を確認・承認

## なぜAIが可読しやすいのか

### UFMLの構造化された記法の優位性

#### 従来のMarkdown記述との比較

**従来のMarkdown記述例:**
```markdown
## ログイン画面
ユーザーはメールアドレスとパスワードを入力します。
ログインボタンを押すと認証が行われ、成功した場合はメインメニューに遷移します。
失敗した場合はエラーメッセージを表示します。

### 非機能要件
- レスポンス時間は1秒以内
- セキュリティ要件として多要素認証が必要
```

**UFML記述例:**
```
[ログイン画面]
//P: response_time <= 1s
//S: multi_factor_auth=required

E メールアドレス
E パスワード
B ログイン
--
A ログイン認証 ={認証成功}=> メインメニュー
A ログイン認証 ={認証失敗}=> ログイン画面
```

#### AIにとっての可読性の違い

##### 1. **構造の明確性**
- **Markdown**: 自然言語による曖昧な表現、構造の推測が必要
- **UFML**: 明確な記号体系（T/E/B/O、//P/S/A/U、A =>）による構造化

##### 2. **要素の識別精度**
- **Markdown**: 「ボタン」「入力フィールド」などの自然言語から要素タイプを推測
- **UFML**: `B ログイン`、`E メールアドレス` など、記号による明確な要素タイプ定義

##### 3. **条件分岐の表現**
- **Markdown**: 「成功した場合は...、失敗した場合は...」という自然言語による条件表現
- **UFML**: `={認証成功}=>`、`={認証失敗}=>` による構造化された条件表現

##### 4. **非機能要件の関連付け**
- **Markdown**: 別セクションでの記述、画面との関連性が曖昧
- **UFML**: `//P:`、`//S:` による画面ブロック内での直接的な関連付け

##### 5. **パースの容易性**
- **Markdown**: 自然言語処理が必要、文脈理解が困難
- **UFML**: 正規表現やシンプルなパーサーで確実に解析可能

#### LLMによる処理精度の向上

UFMLの構造化された記法により、LLMは以下の処理を高精度で実行できます：

1. **要素抽出**: `T`/`E`/`B`/`O` による確実な要素タイプ識別
2. **遷移解析**: `A [説明] => [遷移先]` による明確な遷移関係の把握
3. **条件分析**: `={条件}=>` による条件分岐の正確な理解
4. **要件マッピング**: `//P:`/`//S:`/`//A:`/`//U:` による非機能要件の確実な抽出

この構造化により、LLMは推測や解釈に頼ることなく、確実で一貫性のある分析・生成を実現できます。
